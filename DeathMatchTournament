class DeathMatchTournament(Tournament):
    def __init__(self, strategies, win_goal=3):
        if len(strategies) != 2:
            raise ValueError("DeathMatchTournament requires exactly 2 strategies!")
        super().__init__(strategies, mode="DeathMatchTournament")
        self.win_goal = win_goal
        self.num_of_games = 0

    def run(self):
        history = []
        scores = {s.__class__.__name__: 0 for s in self.strategies}

        while max(scores.values()) < self.win_goal:
            self.num_of_games += 1
            winner, result_str = super().run(self.strategies[0], self.strategies[1])

            if not winner:  # אם יש תיקו – בוחרים מנצח אקראי
                import random
                winner = random.choice(self.strategies)
                result_str = winner.__class__.__name__
                print(f"Draw → בחירה אקראית: {result_str}")

            # עדכון ניקוד
            scores[winner.__class__.__name__] += 1

            # שמירת ההיסטוריה של המשחק
            history.append({
                "game": self.num_of_games,
                "player1": self.strategies[0].__class__.__name__,
                "player2": self.strategies[1].__class__.__name__,
                "winner": result_str
            })

        champion = max(scores, key=lambda k: scores[k])
        print(f"\nChampion: {champion}")
        print("History of matches:")
        for match in history:
            print(f"Game {match['game']}: {match['player1']} vs {match['player2']} → Winner: {match['winner']}")
